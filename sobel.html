<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Example: Image Processing - rust-training-aug19</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="installation_win.html"><strong aria-hidden="true">1.</strong> Installation (Windows)</a></li><li><a href="anatomy.html"><strong aria-hidden="true">2.</strong> Anatomy</a></li><li><a href="data_types.html"><strong aria-hidden="true">3.</strong> Data types</a></li><li><a href="control.html"><strong aria-hidden="true">4.</strong> Control Structures</a></li><li><a href="error_handling.html"><strong aria-hidden="true">5.</strong> Option and Result</a></li><li><a href="traits.html"><strong aria-hidden="true">6.</strong> Traits</a></li><li><a href="external_dependencies.html"><strong aria-hidden="true">7.</strong> External dependencies</a></li><li><a href="enums.html"><strong aria-hidden="true">8.</strong> Enum</a></li><li><a href="borrowing.html"><strong aria-hidden="true">9.</strong> Borrowing, cloning, and scopes</a></li><li><a href="vec_generics.html"><strong aria-hidden="true">10.</strong> Vec, an intro to generics</a></li><li><a href="iterators.html"><strong aria-hidden="true">11.</strong> Iterators</a></li><li><a href="sobel.html" class="active"><strong aria-hidden="true">12.</strong> Example: Image Processing</a></li><li><a href="rayon.html"><strong aria-hidden="true">13.</strong> Rayon</a></li><li><a href="org.html"><strong aria-hidden="true">14.</strong> Code Organization &amp; Modules</a></li><li><a href="extra.html"><strong aria-hidden="true">15.</strong> Extra Credit</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">rust-training-aug19</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#image-processing-example" id="image-processing-example">Image Processing Example</a></h1>
<p>It's time now; we're going to build a bigger example project.</p>
<p>For this example we're going to build a simple utility for applying the <a href="https://en.wikipedia.org/wiki/Sobel_operator">Sobel operator</a> to an input image and outputting the image. What's the Sobel operator? It's one of several methods for highlighting edges in an image, and looks like this:</p>
<p><img src="./images/valve.png" alt="Before Sobel" />
<img src="./images/valve_sobel.png" alt="After Sobel" /></p>
<p>The Sobel operator is represented as a kernel that is convolved with an image to produce the output. <a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)#Convolution">Convolving a kernel with an image</a> is an incredibly common operation in all kinds of image processing.</p>
<p>In our Sobel example, we will use the kernels below, which calculate estimates of the gradient: Gx and Gy. In an image, the gradient describes how fast the color of the image is changing in a direction, X and Y in this case. Typically, edges change very quickly, so if we output the gradient of the image, we expect the edges to have high values.</p>
<p>In these equations, Gx and Gy are the gradients (how fast the color is changing) in the X and Y directions. The matrix is the kernel and A is the block of pixels we're convolving with the kernel.</p>
<p><img src="./images/sobel_eq.svg" alt="Sobel kernel equations" /></p>
<p>That may sound complicated, but it boils down to this: multiply each pixel in the block (matrix A of pixel values) with the corresponding value in the kernel matrix, and then add up all the results.</p>
<p>To do this for a whole image, we slide the matrix A around so that the pixel we're processing is the center.</p>
<p>Let's get going!</p>
<h2><a class="header" href="#input-parameters" id="input-parameters">Input parameters</a></h2>
<p>To specify the input and output image paths, we'll parse args from <code>std::env::args()</code> using the same method we explored earlier.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">use std::env;

struct Opt {
    input_path: String,
    output_path: String,
}

fn options() -&gt; Option&lt;Opt&gt; {
    Some(Opt {
        input_path: env::args().nth(1)?,
        output_path: env::args().nth(2)?,
    })
}

fn main() {
    let options = options().expect(&quot;Failed to parse command options!&quot;);
}
</code></pre></pre>
<h2><a class="header" href="#loading-the-input-image" id="loading-the-input-image">Loading the input image</a></h2>
<p>For now, let's just write the input to the output, passthrough, using the image create we looked at earlier.</p>
<pre><code class="language-rust ignore">let input_image = image::open(&amp;options.input_path)
    .expect(&quot;Failed to open input image file&quot;);

input_image.save(&amp;options.output_path)
    .expect(&quot;Failed to save output image to file&quot;);
</code></pre>
<h2><a class="header" href="#converting-to-grayscale-or-luma" id="converting-to-grayscale-or-luma">Converting to grayscale (or luma)</a></h2>
<p>In order to apply our Sobel operator from above, we're going to need an image in grayscale, with one value per pixel. We also eventually need to the values to be floating-point, but first let's convert to grayscale. Converting an RGB image to grayscale requires specific weights per component, but luckily the image create already implements this for us. We just need to figure out how to use it. Let's take a look at the docs again.</p>
<p><img src="./images/image-load-doc.png" alt="image::load docs" /></p>
<h3><a class="header" href="#quick-look-at-custom-error-types-and-result-aliases" id="quick-look-at-custom-error-types-and-result-aliases">Quick look at custom error types and Result aliases</a></h3>
<p>The <code>load</code> function returns an <code>ImageResult</code>. This is a custom Result enum in the image crate, which is just a shortcut for <code>Result&lt;DynamicImage, ImageError&gt;</code> where <code>ImageError</code> is another enum in the crate with all the possible errors.</p>
<p>This pattern is pretty typical for crates, both to encapsulate their possible errors in one enum and to create a type alias for Result to simplify declarations. If you click on <code>ImageError</code> in the docs, you can see the detailed definition of the possible errors.</p>
<p><img src="./images/image-err.png" alt="image::ImageError docs" /></p>
<p>If you want to handle errors in specific ways, you can use a match statement. You can even ignore some errors if you want and just panic, usually only if you're writing an app, not a library. If you're writing a library, you typically want to encapsulate errors and pass them back to the caller for handling.</p>
<pre><code class="language-rust ignore"># extern crate image; // once again, limitation of Rust playground

fn main() {
    let image = match image::open(&quot;filename.png&quot;) {
        Err(image::ImageError::UnsupportedError(s)) =&gt;
            panic!(&quot;Try a different format: {}&quot;, s),
        Err(_) =&gt;
            panic!(&quot;Failed to load image file!&quot;),
        Ok(img) =&gt; img
    };
}
</code></pre>
<h3><a class="header" href="#to_luma-method" id="to_luma-method">to_luma() method</a></h3>
<p>From looking at the <a href="https://docs.rs/image/0.22.1/image/enum.DynamicImage.html#method.to_luma">docs</a> on <code>image::open</code> we now know that it returns a <code>DynamicImage</code> type. If we peek at the <code>DynamicImage</code> docs we'll find a function called <code>to_luma()</code>, which is exactly what we want. Notice it returns a different type, <code>GrayImage</code>.</p>
<p>Since types and abstractions in Rust don't incur overhead, it's pretty typically to use more types than less to represent different possible data structures and formats. This not only makes code clear to the reader, but also allows the compiler to help you enforce invariants.</p>
<p>For example, we can make our processing code later only accept <code>GrayImage</code> as input, which makes sure the caller has converted any inputs.</p>
<p><img src="./images/to_luma.png" alt="to_luma method" /></p>
<pre><code class="language-rust ignore">let input_image = image::open(&amp;options.input_path)
    .expect(&quot;Failed to open input image file&quot;);

let gray_image = input_image.to_luma();

gray_image.save(&amp;options.output_path)
    .expect(&quot;Failed to save output image to file&quot;);
</code></pre>
<p>The output image should now look like:</p>
<p><img src="./images/valve_gray.png" alt="Valve after to_luma" /></p>
<h2><a class="header" href="#defining-the-kernels" id="defining-the-kernels">Defining the kernels</a></h2>
<p>We can define the kernels multiple ways, but for now let's use a fixed size array of fixed size arrays. This preserves the row and column structure of the kernels. We'll use the const keyword to define these as constant, static data outside of any function. The compiler will not let us in any way mutate this data.</p>
<pre><code class="language-rust ignore">/// Kernel for the Sobel operator in the X direction
const SOBEL_KERNEL_X: [[f32; 3]; 3] = [
    [-1.0, -2.0, -1.0],
    [0.0, 0.0, 0.0],
    [1.0, 2.0, 1.0]
];

/// Kernel for the Sobel operator in the Y direction
const SOBEL_KERNEL_Y: [[f32; 3]; 3] = [
    [-1.0, 0.0, 1.0],
    [-2.0, 0.0, 2.0],
    [-1.0, 0.0, 1.0]
];
</code></pre>
<h2><a class="header" href="#convolution" id="convolution">Convolution</a></h2>
<p>As we explored above, the convolution operator for a kernel and a block of pixels boils down to a pretty simple series of operations. First we multiple each value from the kernel matrix with its corresponding value in the block of pixels, and then, we sum up all the products. Usually, we also divide by a constant value to &quot;normalize&quot; the result (really just make sure it is within the 0.0-1.0 range). For the Sobel operator on a 3x3 block of pixels, a divisor of 8.0 works well.</p>
<p>Let's start with the function signature:</p>
<pre><code class="language-rust ignore">fn convolve(kernel: &amp;[[f32; 3]; 3], pixels: &amp;[[f32; 3]; 3]) -&gt; f32 {

}
</code></pre>
<p>Notice that both the kernel and pixels are borrowed, not moved, since the kernel will be re-used for all pixels. At least while starting out in Rust, prefer borrowing to moving unless you have a good reason.</p>
<p>Now it's time to put some meat into the function. Here we use <code>zip</code> to combine two iterators into one iterator that yields tuple elements. Since kernel and pixels are nested arrays, <code>kernel.iter()</code> and <code>pixels.iter()</code> both give iterators over elements of type <code>[f32; 3]</code>. So, the tuple parameter <code>(kernel_col, input_col)</code> has type <code>([f32; 3], [f32; 3])</code>. Therefore in the closure, we iterate and zip once again, to yield elements of type <code>(f32, f32)</code> that we can multiply together. Finally we use the sum combinator to add all the products up.</p>
<pre><code class="language-rust ignore">fn convolve(kernel: &amp;[[f32; 3]; 3], pixels: &amp;[[f32; 3]; 3]) -&gt; f32 {
    let accumulator: f32 = kernel
        .iter()
        .zip(pixels.iter())
        .flat_map(|(kernel_col, input_col)| {
            kernel_col
                .iter()
                .zip(input_col.iter())
                .map(|(k, p)| k * p)
        })
        .sum();
    // normalize
    accumulator / 8.0
}
</code></pre>
<p>Let's write a quick sanity test for our convolution function. Typically, tests are separated into a &quot;tests&quot; module, but kept inline with the code they verify. So, in our main file we can create a module, and mark it so that it is only compiled in the test configuration. Any function marked with <code>#[test]</code> will be run as a test.</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_convolution() {

    }
}
</code></pre>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_convolution() {
        let pixels: [[f32; 3]; 3] = [
            [1.0, 2.0, 3.0],
            [4.0, 5.0, 6.0],
            [7.0, 8.0, 9.0]
        ];
        assert_eq!(convolve(&amp;SOBEL_KERNEL_X, &amp;pixels), 3.0);
        assert_eq!(convolve(&amp;SOBEL_KERNEL_Y, &amp;pixels), 1.0);
    }
}
</code></pre>
<p>Run the tests with <code>cargo test</code> and we should see passing tests.</p>
<h2><a class="header" href="#getting-the-pixels" id="getting-the-pixels">Getting the pixels</a></h2>
<p>Our convolution function is ready, but we are missing the connection between the image we converted to luma and the convolution operator. Let's look into the <a href="https://docs.rs/image/0.22.1/image/type.GrayImage.html">docs on GrayImage</a> to see how we can get pixel values out.</p>
<p><img src="./images/gray-image-docs.png" alt="GrayImage docs" /></p>
<p>At first glance, it doesn't look like there are many methods, huh?</p>
<p>Let's take a closer look. <code>GrayImage</code> is defined as a type alias of a specific variation of ImageBuffer (using generic type parameters). If we click on <code>ImageBuffer</code> (usually in Rust docs, you can click on a type name to see its docs), we will see the <a href="https://docs.rs/image/0.22.1/image/struct.ImageBuffer.html">full list of available methods</a>.</p>
<p><img src="./images/image-get-pixel-docs.png" alt="get_pixel docs" /></p>
<p>There's a <code>get_pixel</code> method! Oh, but the return type is <code>&amp;P</code>, that's weird. If we look at the declaration of ImageBuffer though, we see that <code>P</code> must implement the <code>Pixel</code> trait. And if we look at the <code>Pixel</code> <a href="">trait docs</a>, we see a method called <code>channels()</code> that gives us a slice of the pixel's values, one for each channel. Since out image is grayscale (luma), we expect just one channel.</p>
<p>This might seem over-complicated. However, by abstracting away the underlying storage formats, the &quot;image&quot; crate lets users build processing systems that are general over many image formats. Remember, the Rust compiler boils down all of the abstractions into highly optimized code. So we can have our generics and safety while writing high-performance code!</p>
<p>For our case, we just have a GrayImage with pixels of type <code>Luma&lt;u8&gt;</code> that implement the <code>Pixel</code> trait. So we should be able to fetch a pixel pretty easily. Here's a go:</p>
<pre><code class="language-rust ignore">use image::Pixel; // trait for '.channels()'

...

let input_image = image::open(&amp;options.input_path)
    .expect(&quot;Failed to open input image file&quot;);

let gray_image = input_image.to_luma();

println!(&quot;Pixel 0, 0: {}&quot;, gray_image.get_pixel(0, 0).channels()[0]);

gray_image.save(&amp;options.output_path)
    .expect(&quot;Failed to save output image to file&quot;);
</code></pre>
<p>Generally, well-written Rust crates provide comprehensive types like this to cover the data formats and structures that they operate on. An image library in C/C++ may provide a raw buffer of pixels, which is easy to access. But, as soon as you have to deal with multiple formats, multiple pixel orderings (RGB, BGR, RGBA, etc.), it can be difficult to ensure all code branches are correct. With Rust, the type system will catch these errors at compile time.</p>
<p>Now that we can grab pixels, let's write a function that takes the pixel values and calls our convolution function. First we'll start with this signature, and copying the input. We need a place to store the resulting convolved pixel values, and we want an image of the same dimensions and data types. <code>clone()</code> is an easy way to get that. Notice that <code>result</code> is declared as <code>mut</code> since we will be modifying its contents.</p>
<pre><code class="language-rust ignore">use image::GrayImage;

fn sobel_filter(input: &amp;GrayImage) -&gt; GrayImage {
    let mut result = input.clone();

    result
}
</code></pre>
<p>To start with, let's just create the block of pixels to feed the convolution for each center pixel.</p>
<pre><code class="language-rust ignore">fn sobel_filter(input: &amp;GrayImage) -&gt; GrayImage {
    let mut result = input.clone();

    for x in 0..input.width() {
        for y in 0..input.height() {
            let pixels = [
                [input.get_pixel(x - 1, y - 1).channels()[0],
                 input.get_pixel(x - 1, y).channels()[0],
                 input.get_pixel(x - 1, y + 1).channels()[0]],
                [input.get_pixel(x, y - 1).channels()[0],
                 input.get_pixel(x, y).channels()[0],
                 input.get_pixel(x, y + 1).channels()[0]],
                [input.get_pixel(x + 1, y - 1).channels()[0],
                 input.get_pixel(x + 1, y).channels()[0],
                 input.get_pixel(x + 1, y + 1).channels()[0]]];
        }
    }

    result
}
</code></pre>
<p>We'll need to throw a call into <code>fn main()</code> to use this:</p>
<pre><code class="language-rust ignore">let input_image = image::open(&amp;options.input_path)
    .expect(&quot;Failed to open input image file&quot;);

let gray_image = input_image.to_luma();

let output_image = sobel_filter(&amp;gray_image);

output_image.save(&amp;options.output_path)
    .expect(&quot;Failed to save output image to file&quot;);
</code></pre>
<p>And then when we run this... what happened?!? What does it mean we attempted subtraction with overflow?</p>
<p>Well, in Rust debug builds, the primitive integer types are checked for overflows an underflows in the basic operations. Don't worry, these are not enabled in the release build unless you specifically want.</p>
<p>And, just like now, the overflow checks in debug builds help catch bugs early on.</p>
<h2><a class="header" href="#handling-the-edges" id="handling-the-edges">Handling the edges</a></h2>
<p>The overflow is happening because of the <code>x - 1</code> and <code>y - 1</code> when x or y is zero. This is indicative of a bigger question: how should we handle the edges of the image?</p>
<p>As the <a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)#Edge_Handling">Wikipedia page on convolution kernels</a> explains, there are several ways:</p>
<ul>
<li>Extend the image by duplicating pixels at the edge</li>
<li>Wrap around to the other side</li>
<li>Crop the output image 2 pixels smaller in X and Y</li>
<li>Crop the kernel on the edges and corners</li>
</ul>
<p>If we crop the output image, we can easily adapt our code. The ImageBuffer struct implements the GenericImage trait which has a function called <code>sub_image</code> that gives us a view into rectangular section of an image. With a <code>SubImage</code> we can call <code>to_image()</code> to get a cropped <code>ImageBuffer</code> back out.</p>
<pre><code class="language-rust ignore">use image::GenericImage;

fn sobel_filter(input: &amp;GrayImage) -&gt; GrayImage {
    let mut result = input
        .sub_image(1, 1, input.width() - 2, input.height() - 2)
        .to_image();

    for x in 1..(input.width() - 1) {
        for y in 1..(input.height() - 1) {
            let pixels = [
                [input.get_pixel(x - 1, y - 1).channels()[0],
                 input.get_pixel(x - 1, y).channels()[0],
                 input.get_pixel(x - 1, y + 1).channels()[0]],
                [input.get_pixel(x, y - 1).channels()[0],
                 input.get_pixel(x, y).channels()[0],
                 input.get_pixel(x, y + 1).channels()[0]],
                [input.get_pixel(x + 1, y - 1).channels()[0],
                 input.get_pixel(x + 1, y).channels()[0],
                 input.get_pixel(x + 1, y + 1).channels()[0]]];
        }
    }

    result
}
</code></pre>
<p>Cool. No more overflows. We should get the convolution in there! Oh, and did you find a place where clone might be handy?</p>
<pre><code class="language-rust ignore">use image::GenericImage;

fn sobel_filter(input: &amp;GrayImage) -&gt; GrayImage {
    let mut result = input
        .clone()
        .sub_image(1, 1, input.width() - 2, input.height() - 2)
        .to_image();

    for x in 1..(input.width() - 1) {
        for y in 1..(input.height() - 1) {
            let pixels = [
                [input.get_pixel(x - 1, y - 1).channels()[0],
                 input.get_pixel(x - 1, y).channels()[0],
                 input.get_pixel(x - 1, y + 1).channels()[0]],
                [input.get_pixel(x, y - 1).channels()[0],
                 input.get_pixel(x, y).channels()[0],
                 input.get_pixel(x, y + 1).channels()[0]],
                [input.get_pixel(x + 1, y - 1).channels()[0],
                 input.get_pixel(x + 1, y).channels()[0],
                 input.get_pixel(x + 1, y + 1).channels()[0]]];

            let gradient_x = convolve(&amp;SOBEL_KERNEL_X, &amp;pixels);
            let gradient_y = convolve(&amp;SOBEL_KERNEL_Y, &amp;pixels);
        }
    }

    result
}
</code></pre>
<p>Uh oh. Now we have a different problem. Our <code>GrayImage</code> gives us <code>u8</code> from <code>get_pixel(x, y).channels()[0]</code>, but <code>convolve</code> expects the pixels to be f32. In fact, our convolution also expects the pixels to be in the range [0.0-1.1].</p>
<h2><a class="header" href="#lumafloat-trait" id="lumafloat-trait">LumaFloat trait</a></h2>
<p>This is a great time to build a new trait! We can create a trait with a new <code>get_float_luma()</code> function and implement it for GrayImage. Since we're also going to be writing pixels to the output image, let's also add a <code>put_float_luma()</code> method.</p>
<pre><code class="language-rust ignore">trait LumaFloat {
    fn get_float_luma(&amp;self, x: u32, y: u32) -&gt; f32;
    fn put_float_luma(&amp;mut self, x: u32, y: u32, luma: f32);
}

impl LumaFloat for GrayImage {
    fn get_float_luma(&amp;self, x: u32, y: u32) -&gt; f32 {
        self.get_pixel(x, y)[0] as f32 / 255.0
    }

    fn put_float_luma(&amp;mut self, x: u32, y: u32, luma: f32) {
        self.put_pixel(x, y, Luma([(luma * 255.0) as u8]));
    }
}
</code></pre>
<p>Now in our Sobel filter function, things get a lot cleaner. We can also add a couple lines to compute the magnitude of the gradient and store it back to the resulting image.</p>
<pre><code class="language-rust ignore">use image::{GenericImage, GrayImage, Luma};

fn sobel_filter(input: &amp;GrayImage) -&gt; GrayImage {
    let mut result = input
        .clone()
        .sub_image(1, 1, input.width() - 2, input.height() - 2)
        .to_image();

    for x in 1..(input.width() - 1) {
        for y in 1..input.height() - 1 {
            let pixels = [
                [input.get_float_luma(x - 1, y - 1),
                 input.get_float_luma(x - 1, y),
                 input.get_float_luma(x - 1, y + 1)],
                [input.get_float_luma(x, y - 1),
                 input.get_float_luma(x, y),
                 input.get_float_luma(x, y + 1)],
                [input.get_float_luma(x + 1, y - 1),
                 input.get_float_luma(x + 1, y),
                 input.get_float_luma(x + 1, y + 1)]];

            let gradient_x = convolve(&amp;SOBEL_KERNEL_X, &amp;pixels);
            let gradient_y = convolve(&amp;SOBEL_KERNEL_Y, &amp;pixels);
            let magnitude = (gradient_x.powi(2) + gradient_y.powi(2)).sqrt();
            result.put_float_luma(x - 1, y - 1, magnitude);
        }
    }

    result
}
</code></pre>
<p>Now if we <code>cargo run</code>, the output should be interesting. If the runtime is a bit long, you might try <code>cargo run --release</code>. Running in release mode can make a massive difference.</p>
<h2><a class="header" href="#we-have-a-sobel-filter" id="we-have-a-sobel-filter">We have a Sobel Filter!</a></h2>
<p><img src="./images/valve_sobel.png" alt="Result image" /></p>
<h2><a class="header" href="#extra-credit" id="extra-credit">Extra credit</a></h2>
<ul>
<li>Can you implement edge extension instead of cropping?</li>
<li>Can you implement a box blur instead of the Sobel operator?</li>
<li>Can you extend the command line interface to allow the user to select what filter to apply?</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="iterators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="rayon.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="iterators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="rayon.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
